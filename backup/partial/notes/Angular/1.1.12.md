## 依赖注入

AngularJS使用`$injetor`（注入器服务）来管理依赖关系的查询和实例化。事实上，`$injetor`负责实例化AngularJS中所有的组件，包括应用的模块、指令和控制器等。

在运行时， 任何模块启动时$injetor都会负责实例化，并将其需要的所有依赖传递进去。

### 注入声明的几种方法

1. **推断式注入声明**

 如果没有明确的声明，AngularJS会假定参数名称就是依赖的名称。因此，它会在内部调用函数对象的toString()方法，分析并提取出函数参数列表，然后通过$injector将这些参数注入进对象实例。

 这个过程只适用于未经过压缩和混淆的代码，因为AngularJS需要原始未经压缩的参数列表来进行解析。

2. **显式注入声明**
 
 AngularJS提供了显式的方法来明确定义一个函数在被调用时需要用到的依赖关系。通过这种方法声明依赖，即使在源代码被压缩、参数名称发生改变的情况下依然能够正常工作。

 可以通过$inject属性来实现显式注入声明的功能。函数对象的`$inject`属性是一个数组，数组元素的类型是字符串，它们的值就是需要被注入的服务的名称。

 ```js
 var aControllerFactory =
 function aController($scope, greeter) {
    console.log("LOADED controller", greeter);
    // ……控制器
    };
 aControllerFactory.$inject = ['$scope', 'greeter']; 
 // Greeter服务
 var greeterService = function() {
    console.log("greeter service");
 }

 // 我们应用的控制器
 angular.module('myApp', [])
    .controller('MyController', aControllerFactory)
    .factory('greeter', greeterService);
 // 获取注入器并创建一个新的作用域
 
 var injector = angular.injector(['ng', 'myApp']),
    controller = injector.get('$controller'),
    rootScope = injector.get('$rootScope'),
    newScope = rootScope.$new();
    // 调用控制器
    controller('MyController', {$scope: newScope});

 ```
 
 对于这种声明方式来讲，参数顺序是非常重要的，因为$inject数组元素的顺序必须和注入参数的顺序一一对应。这种声明方式可以在压缩后的代码中运行，因为声明的相关信息已经和函数本身绑定在一起了。

3. 行内注入声明
 
 AngularJS提供的注入声明的最后一种方式，是可以随时使用的行内注入声明。这种方式其实是一个语法糖，它同前面提到的通过$inject属性进行注入声明的原理是完全一样的，但允许我们在函数定义时从行内将参数传入。此外，它可以避免在定义过程中使用临时变量。

 在定义一个AngularJS的对象时，行内声明的方式允许我们直接传入一个参数数组而不是一个函数。数组的元素是字符串，它们代表的是可以被注入到对象中的依赖的名字，最后一个参数就是依赖注入的目标函数对象本身。
 
 ```
    angular.module('myApp')
        .controller('MyController', ['$scope', 'greeter', function($scope, greeter) {
        }]);
 ```

 由于需要处理的是一个字符串组成的列表，行内注入声明也可以在压缩后的代码中正常运行。通常通过括号和声明数组的[]符号来使用它。

### $injector API

在实际工作中，我们很少直接同`$injector`打交道，但是了解一下`$injector`有哪些API，可以帮助我们更好地理解它是如何运作的。

1. **annotate()**
 
 annotate()方法的返回值是一个由服务名称组成的数组，这些服务会在实例化时被注入到目标函数中。 annotate()方法可以帮助`$injector`判断哪些服务会在函数被调用时注入进去。

 annotate()方法可以接受一个参数：
 - fn（函数或数组）
 
 参数fn可以是一个函数，也可以是一个数组。 annotate()方法返回一个数组，数组元素的值是在调用时被注入到目标函数中的服务的名称。

2. **get()**
 
 get()方法返回一个服务的实例，可以接受一个参数：

 - name（字符串）
     + 参数name是想要获取的实例的名称。get()根据名称返回服务的一个实例。

3. **has()**
 
 has()方法返回一个布尔值，在`$injector`能够从自己的注册列表中找到对应的服务时返回true，否则返回false。它能接受一个参数：
 - name（字符串）
     + 参数name是我们想在注入器的注册列表中查询的服务名称。

4. **instantiate()**
 
 instantiate()方法可以创建某个JavaScript类型的实例。它会通过new操作符调用构造函数，并将所有参数都传递给构造函数。它可以接受两个参数。
 - **Type**（函数）
     + 构造函数。
 - **locals**（对象，可选）
     + 这是一个可选的参数，提供了另一种传递参数的方式。
 
 instantiate()方法返回Type的一个新实例。

5. **invoke()**
 
 invoke()方法会调用方法并从`$injector`中添加方法参数。
 invoke()方法接受三个参数。
 - fn(function)
     + 这个函数就是要调用的函数。这个函数的参数由函数声明设置。
 - self (object-可选)
     + self参数允许我们设置调用方法的this参数。
 - locals (object-可选)
     + 这个可选参数提供另一种方式在函数被调用时传递参数名给该函数。
 invoke()方法返回fn函数返回的值。


### ngMin

ngMin是一个为AngularJS应用设计的预压缩工具，它会遍历整个AngularJS应用并帮助我们设置好依赖注入。

例如，它会将如下代码：

```js
angular.module('myApp', [])
    .directive('myDirective', function($http) { })
    .controller('IndexController', function($scope, $q) {
    });
```

转换成下面的形式：

```js
angular.module('myApp', [])
    .directive('myDirective', ['$http', function ($http) { }])
    .controller('IndexController', [ '$scope', '$q',function ($scope, $q) {} ]);
```


我们可以在命令行界面单独使用ngMin，可以通过标准输入输出设备或标准输出流传入
input.js和output.js两个参数，例如：

```
$ ngmin input.js output.js
#或者
$ ngmin < input.js > output.js
```

input.js是源文件，而 output.js则是转换过注入声明后的输出文件。

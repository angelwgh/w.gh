## 表单验证

要使用表单验证，首先要确保表单有一个name属性。所有输入字段都可以进行基本的验证，比如最大、最小长度等。这些功能是由新的HTML5表单属性提供的。如果想要屏蔽浏览器对表单的默认验证行为，可以在表单元素上添加novalidate标记。

#### 在input元素上使用的所有验证选项。

1. **必填项**
 
 验证某个表单输入是否已填写，只要在输入字段元素上添加HTML5标记required即可：

2. **最小长度**
 
 验证表单输入的文本长度是否大于某个最小值，在输入字段上使用AngularJS指令`ng-minleng="{number}"`

3. **最大长度**
 
 验证表单输入的文本长度是否小于或等于某个最大值，在输入字段上使用AngularJS指令
`ng-maxlength="{number}"`：

4. **匹配模式**
 
 使用`ng-pattern="/PATTERN/"`来确保输入能够匹配指定的正则表达式：
 ```html
 <input type="text" ng-pattern="[a-zA-Z]" />
 ```

5. **电子邮件**
 
 验证输入内容是否是电子邮件，只要像下面这样将input的类型设置为email即可：
 ```html
<input type="email" name="email" ng-model="user.email" />
 ```
 
6. **数字**
 
 验证输入内容是否是数字，将input的类型设置为number

7. **URL**
 
 验证输入内容是否是URL，将input的类型设置为 url：

8. **自定义验证**
 
 后面自定义指令中介绍

9. 在表单中控制变量
 
 表单的属性可以在其所属的`$scope`对象中访问到，而我们又可以访问`$scope`对象，因此JavaScript可以间接地访问DOM中的表单属性。借助这些属性，我们可以对表单做出实时（和AngularJS中其他东西一样）响应。这些属性包括下面这些。

 可以使用下面的格式访问这些属性:
 ```
 formName.inputFieldName.property
 ```

 - **未修改的表单**
    + 这是一个布尔属性，用来判断用户是否修改了表单。如果未修改，值为`true`，如果修改过值为`false`：
     ```
     formName.inputFieldName.$pristine
     ```

 - **修改过的表单**
    + 只要用户修改过表单，无论输入是否通过验证，该值都返回`true`：
    ```
        formName.inputFieldName.$dirty
    ```

 - **合法的表单**
    + 这个布尔型的属性用来判断表单的内容是否合法。如果当前表单内容是合法的，下面属性的值就是`true`：
    ```
    formName.inputFieldName.$valid
    ```

 - **不合法的表单**
    + 这个布尔属性用来判断表单的内容是否不合法。如果当前表单内容是不合法的，下面属性的值为`true`：
    ```
    formName.inputFieldName.$invalid
    ```

 - **错误**
    + 这是AngularJS提供的另外一个非常有用的属性： `$error`对象。它包含当前表单的所有验证内容，以及它们是否合法的信息。用下面的语法访问这个属性：
    ```
    formName.inputfieldName.$error
    ```
    如果验证失败，这个属性的值为true；如果值为false，说明输入字段的值通过了验证。

10. **一些有用的CSS样式**
 
 AngularJS处理表单时，会根据表单当前的状态添加一些CSS类（例如当前是合法的、未发生变化的，等等），这些CSS类的命名和前面介绍的属性很相似。

 ```
.ng-pristine {}
.ng-dirty {}
.ng-valid {}
.ng-invalid {}
 ```
 
 它们对应着表单输入字段的特定状态。
 当某个字段中的输入非法时， `.ng-invlid`类会被添加到这个字段上。

· **$parsers**

当用户同控制器进行交互，并且`ngModelController`中的`$setViewValue()`方法被调用时，`$parsers`数组中的函数会以流水线的形式被逐个调用。第一个`$parse`被调用后，执行结果会传递给第二个`$parse`，以此类推。

这些函数可以对输入值进行转换，或者通过`$setValidity()`函数设置表单的合法性。
使用`$parsers`数组是实现自定义验证的途径之一。例如，假设我们想要确保输入值在某两个数值之间，可以在`$parsers`数组中入栈一个新的函数，这个函数会在验证链中被调用。

每个`$parser`返回的值都会被传入下一个`$parser`中。当不希望数据模型发生更新时返回`undefined`。

```
angular.module('myApp')
    .directive('oneToTen', function() {
        return {
            require: '?ngModel',
            link: function(scope, ele, attrs, ngModel) {
                if (!ngModel) return;
                ngModel.$parsers.unshift(
                function(viewValue) {
                    var i = parseInt(viewValue);

                    if (i >= 0 && i < 10) {
                        ngModel.$setValidity('oneToTen', true);
                        return viewValue;
                    } else {
                        ngModel.$setValidity('oneToTen', false);
                        return undefined;
                    }
                });
            }
        };
    });
```


· **$formatters**

当绑定的ngModel值发生了变化，并经过`$parsers`数组中解析器的处理后，这个值会被传递
给`$formatters`流水线。同`$parsers`数组可以修改表单的合法性状态类似，`$formatters`中的函数也可以修改并格式化这些值。

比起单纯的验证目的，这些函数更常用来处理视图中的可视变化。例如，假设我们要对某个值进行格式化。通过`$formatters`数组可以在这个值上执行过滤器：

```
angular.module('myApp')
    .directive('oneToTen', function() {
        return {
            require: '?ngModel',
            link: function(scope, ele, attrs, ngModel) {
                if (!ngModel) return;
                    ngModel.$formatters.unshift(function(v) {
                    return $filter('number')(v);
                });
            }
        };
    });
```


### 组合实例

创建一个注册表单。表单中包括用户的名字、邮件地址以及用户名。

```html
<form name="signup_form" novalidate ng-submit="signupForm()">
    <fieldset>
        <legend>Signup</legend>
        <button type="submit" class="button radius">Submit</button>
    </fieldset>
</form>
```

下面添加用户的名字：

```html
<div class="row">
    <div class="large-12 columns">
        <label>Your name</label>
        <input type="text"
        placeholder="Name"
        name="name"
        ng-model="signup.name"
        ng-minlength="3"
        ng-maxlength="20" required />
    </div>
</div>
```

我们添加了一个表单，这个表单有一个名为`name`的输入字段，并且这个输入字段被`ng-model`指令绑定到了`$scope`对象的`signup.name`上。

*不要忘记给输入字段添加name属性。给输入字段添加name属性非常重要：这决
定了我们将验证信息展示给用户时如何引用表单输入字段。*

同时，我们也设置了一些验证。验证要求`name`字段的最小长度是3个字符，最大长度是20个字符（当长度大于等于21时输入会变为不合法）。最后，我们要求`name`字段是必填项。

通过使用这些属性，可以在表单未通过验证时控制展示或隐藏错误列表。用`$dirty`属性来确保用户未对输入内容进行修改时错误内容不会显示出来：

```html
<div class="row">
    <div class="large-12 columns">
        <label>Your name</label>
            <input type="text"
            placeholder="Name"
            name="name"
            ng-model="signup.name"
            ng-minlength="3"
            ng-maxlength="20" required />
        <div class="error"
        ng-show="signup_form.name.$dirty && signup_form.name.$invalid">
            <small class="error"
            ng-show="signup_form.name.$error.required">
                Your name is required.
            </small>
            <small class="error"
            ng-show="signup_form.name.$error.minlength">
                Your name is required to be at least 3 characters
            </small>
            <small class="error"
            ng-show="signup_form.name.$error.maxlength">
                Your name cannot be longer than 20 characters
            </small>
        </div>
    </div>
</div>
```

将整个过程分开来看，我们只是像以前一样在表单发生改变，且输入内容不合法时才展示错误内容。现在，我们会在特定的属性未通过验证时只展示对应的特定DOM元素。

接下来看下一组验证，电子邮箱的验证：

```html
<div class="row">
    <div class="large-12 columns">
        <label>Your email</label>
        <input type="email"
        placeholder="Email"
        name="email"
        ng-model="signup.email"
        ng-minlength="3" ng-maxlength="20" required />
        <div class="error"
        ng-show="signup_form.email.$dirty && signup_form.email.$invalid">
            <small class="error"
            ng-show="signup_form.email.$error.required">
                Your email is required.
            </small>
            <small class="error"
            ng-show="signup_form.email.$error.minlength">
                Your email is required to be at least 3 characters
            </small>
            <small class="error"
            ng-show="signup_form.email.$error.email">
                That is not a valid email. Please input a valid email.
            </small>
            <small class="error"
            ng-show="signup_form.email.$error.maxlength">
                Your email cannot be longer than 20 characters
            </small>
        </div>
    </div>
</div>
```

现在整个表单都被包含进来了，我们来看一下电子邮件的输入字段。注意，我们将输入字段的type属性设置为email，并且在`$error.email`上添加了验证错误的信息。这个验证同时基于AngularJS和HTML5属性实现。

最后，看一下用户名的输入字段：

```html
<div class="large-12 columns">
    <label>Username</label>
    <input type="text"
        placeholder="Desired username"
        name="username"
        ng-model="signup.username"
        ng-minlength="3"
        ng-maxlength="20"
        ensure-unique="username" required />
    <div class="error"
    ng-show="signup_form.username.$dirty &&
        signup_form.username.$invalid">
        <small class="error"
        ng-show="signup_form.username.$error.required">
            Please input a username
        </small>
        <small class="error"
        ng-show="signup_form.username.$error.minlength">
            Your username is required to be at least 3 characters
        </small>
        <small class="error"
        ng-show="signup_form.username.$error.maxlength">
            Your username cannot be longer than 20 characters
        </small>
        <small class="error"
        ng-show="signup_form.username.$error.unique">
            That username is taken, please try another
        </small>
    </div>
</div>
```

在最后一个输入字段中除了同前面相同的验证外，还添加了一个自定义验证。这个自定义验证是用AngularJS指令定义的：

```js
app.directive('ensureUnique', function($http) {
    return {
        require: 'ngModel',
    link: function(scope, ele, attrs, c) {
            scope.$watch(attrs.ngModel, function(n) {
                if (!n) return;
                $http({
                    method: 'POST',
                    url: '/api/check/' + attrs.ensureUnique,
                    data: {
                        field: attrs.ensureUnique,
                        value: scope.ngModel
                    }
                }).success(function(data) {
                    c.$setValidity('unique', data.isUnique);
                }).error(function(data) {
                    c.$setValidity('unique', false);
                });
            });
        }
    };
});

```

最后，把按钮放进去。可以用ng-disabled指令基于表单的合法性来启用或禁用按钮：

```html
    <button type="submit"
            ng-disabled="signup_form.$invalid"
            class="button radius">Submit</button>
```


**在提交后显示验证信息**

当用户试图提交表单时，你可以在作用域中捕获到一个`submitted`值，然后对表单内容进行验证并显示错误信息。

修改一下前面的例子，只在用户提交表单时才显示错误信息。在ng-show指令中加入
对表单是否进行了提交的检查（后面会实现这个功能）:
```html
<form name="signup_form"
    novalidate
    ng-submit="signupForm()"
    ng-controller="signupController">
    <fieldset>
        <legend>Signup</legend>
        <div class="row">
            <div class="large-12 columns">
                <label>Your name</label>
                <input type="text"
                    placeholder="Name"
                    name="name"
                    ng-model="signup.name"
                    ng-minlength="3"
                    ng-maxlength="20" required />
                <div class="error"
                    ng-show="signup_form.name.$dirty && signup_form.name.$invalid &&
                    signup_form.submitted">
                    <small class="error"
                        ng-show="signup_form.name.$error.required">
                    Your name is required.
                    </small>
                    <small class="error"
                        ng-show="signup_form.name.$error.minlength">
                    Your name is required to be at least 3 characters
                    </small>
                    <small class="error"
                        ng-show="signup_form.name.$error.maxlength">
                    Your name cannot be longer than 20 characters
                    </small>
                </div>
            </div>
        </div>
        <button type="submit" >Submit</button>
    </fieldset>
</form>
```
<iframe frameborder="0" width="100%" src="partial/notes/angular/iframe/1.1.7.1.html">
</iframe>

**失去焦点后显示验证信息**

如果想保留实时错误提示的体验，可以在用户从某个输入字段失焦后提示错误信息（例如用户已经不在某个特定的输入字段中时）。为了实现这个效果，需要实现一个不是很复杂的指令，并向表单中添加一个新的变量。

我们需要使用的指令是ngFocus，它是这样的：

```
app.directive('ngFocus', [function() {
    var FOCUS_CLASS = "ng-focused";
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attrs, ctrl) {
                ctrl.$focused = false;
                element.bind('focus', function(evt) {
                    element.addClass(FOCUS_CLASS);
                    scope.$apply(function() {
                        ctrl.$focused = true;
                    });
                }).bind('blur', function(evt) {
                    element.removeClass(FOCUS_CLASS);
                    scope.$apply(function() {
                        ctrl.$focused = false;
                    });
                });
        }
    };
}]);
```

### ngMessages(1.3+)
使用ngMessages模块需引入angular-messages.js文件，然后将ngMessages作为应用程序的依赖模块引入：
```
angular.module('myApp', ['ngMessages']);
```

使用前面的例子作为基
础，你可以移除`ng-show`指令，然后使用ngMessages的一个更简洁的实现替换它。
```html
<form name="signup_form" novalidate ng-submit="signupForm()" ng-controller="signupController">
        <legend>注册</legend>
        <div class="form-group">
            <label>姓名</label>
            <input type="text"
                    name="name"
                    ng-model="signup.name"
                    ng-minlength="3"
                    ng-maxlength="20" required>
            <div class="error" ng-messages="signup_form.name.$error">
                <div ng-bind="signup.name"></div>
                <div ng-message="required" class="alert alert-danger in-b">请输入您的姓名</div>
                <div ng-message="minlength" class="alert alert-danger in-b">至少3个字符</div>
                <div ng-message="maxlength" class="alert alert-danger in-b">不能超过20个字符</div>
            </div>
            <button type="submit">Submit</button>
        </div>
        
    </form>
```

然而对于这个实现，一次只会显示一个错误消息。如果我们想要更新这个实现同时显示所有的错误将会怎样？很容易。只需在ng-message指令旁边使用ng-messages-multiple属性即可。

很多时候这些信息相互之间非常相似。我们可以将它们保存到模板中从而减少麻烦，而不是重新输入每个字段的错误信息。

```
<div ng-message="required">This field is required</div>
<div ng-message="minlength">The field must be at least 3 characters</div>
<div ng-message="maxlength">The field cannot be longer than 20 characters</div>
```

```html
div class="error" ng-messages="signup_form.name.$error" >
    <div class="alert alert-danger" ng-message="minlength">不能少于3个字符</div><!--覆盖模板中的提示-->
    <div ng-class="alert alert-danger" ng-messages-include="templates/errors.html"></div>
     <!--或者这样写
                <ng-messages-include src="templates/errors.html"></ng-messages-include>
            -->
</div>
```

此外，甚至还可以为自定义验证创建自定义消息。可以通过修改模型的 `$parsers`链做到这一点。

例如，比方说我们想要创建一个自定义验证器验证用户名在一个注册表单中是否有效：

```
app.directive('ensureUnipue', function($http) {
    return {
        require: 'ngModel',
        link: function(scope, ele, attrs, ctrl) {
            ctrl.$parsers.push(function(val) {
                // 在这里添加验证
            });
        }
    }
});
```

对于ngModel，你可以添加可以使用ngMessage指令显示/隐藏的自定义信息。还可以添加可
以使用ngMessage指令检查的带有自定义的消息的指令。例如，改变前面使用ngMessages的例子。

```html
<form name="signup_form" novalidate ng-submit="signupForm()" ng-controller="signupController" ensure-unique="/api/checkUsername.json">
    <label>
        Your name
    </label>
    <input type="text" placeholder="Username" name="username" ng-model="signup.username"
        ng-minlength=3 ng-maxlength=20 required />
    <div class="error" ng-messages="signup_form.username.$error">
        <div ng-message="required">
            Make sure you enter your username
        </div>
        <div ng-message="checkingAvailability">
            Checking...
        </div>
        <div ng-message="usernameAvailablity">
            The username has already been taken. Please choose another
        </div>
    </div>
    <button type="submit">
         Submit
    </button>
</form>

```

在这中用法中，我们检查了错误信息的自定义属性。为了添加自定义错误消息，我们将会把它们应用到自定义ensureUnique指令的ngModel中。

```js
app.directive('ensureUnique', function($http) {
    return {
    require: 'ngModel',
    link: function(scope, ele, attrs, ctrl) {
            var url = attrs.ensureUnique;
            ctrl.$parsers.push(function(val) {
                if (!val || val.length === 0) {
                return;
                }
            ngModel.$setValidity('checkingAvailability', true);
            ngModel.$setValidity('usernameAvailablity', false);
            
            $http({
                method: 'GET',
                url: url,
                params: {
                            username: val
                        }
            }).success(function() {
            ngModel.$setValidity('checkingAvailability', false);
            ngModel.$setValidity('usernameAvailablity', true);
          })['catch'](function() {
                    ngModel.$setValidity('checkingAvailability', false);
                    ngModel.$setValidity('usernameAvailablity', false);
                });
            return val;
            })
        }
    }
});
```

## 1.AngularJs中的数据绑定

### Hello Word

```html
<!DOCTYPE html>
<html ng-app>
<head>
    <title>Simple app</title>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.2.13/angular.js"></script>
</head>
<body>
    <input ng-model="name" type="text" placeholder="Your name">
    <h1>Hello {{ name }}</h1>
</body>
</html>
```

<iframe frameborder="0" width="100%" src="partial/notes/angular/iframe/1.1.1.html">
</iframe>

AngularJs用创建实时模版来代替视图，任何一个独立视图组件中的值都是动态替换v的。要实现这个功能，只要在HTML页面中引用angular.js，并在某个DOM元素上明确设置
`ng-app`属性即可。 `ng-app`属性声明所有被其包含的内容都属于这个AngularJS应用只有被具有`ng-app`属性的DOM元素包含的元素才
会受AngularJS影响。

AngularJS采用MVC（Model View Controller，模型视图控制器）模式，在MVC中，控制器可以不必担心会牵
扯到渲染视图的工作，这样我们就不必再担心如何分离视图和控制器逻辑。

> MVC是一种软件架构设计模式，它将表现从用户交互中分离出来。通常来讲，
模型中包含应用的数据和与数据进行交互的方法，视图将数据呈献给用户，而
控制器则是二者之间的桥梁。

AngularJS会记录数据模型所包含的数据在任何特定时间点的值（在Hello World例子中就是
name的值），而不是原始值。

当AngularJS认为某个值可能发生变化时，它会运行自己的事件循环来检查这个值是否变
“脏”。如果该值从上次事件循环运行之后发生了变化，则该值被认为是“脏”值。这也是Angular
可以跟踪和响应应用变化的方式。

> 这个事件循环会调用$digest()循环


这个过程被称作脏检查（dirty checking） 。脏检查是检查数据模型变化的有效手段。当有潜
在的变化存在时， AngularJS会在事件循环时执行脏检查来保证数据的一
致性。


## 2.简单的数据绑定

在上面的Hello Word代码中，我们使用`ng-model`指令将内部数据模型对象（`$scope`）中的`name`
属性绑定到了文本输入字段上。

> 数据模型对象（model object）是指`$scope`对象。 `$scope`对象是一个简单的
JavaScript对象，其中的属性可以被视图访问，也可以同控制器进行交互。如果
不理解这个概念也没有关系，后面的例子将会对这个概念进行详细说明。
双向数据绑定（bi-directional）意味着如果视图改变了某个值，数据模型会通过
脏检查观察到这个变化，而如果数据模型改变了某个值，视图也会依据变化重
新渲染。

跟`ng-app` 声 明 所 有 被 它 包 含 的 元 素 都 属 于 AngularJS 应 用 一 样 ， DOM 元 素 上 的
`ng-controller`声明所有被它包含的元素都属于某个控制器。

我们将前面的例子修改成如下的样子：

``` html
<div ng-controller='MyController'>
    <input ng-model="person.name" type="text" placeholder="Your name">
    <h1>Hello {{ person.name }}</h1>
</div>
```

我们创建一个每秒钟走一步的时钟，并更新clock
变量上的数据。
```js
 angular.module('app',[])
    .controller('MyController', ['$scope','$timeout', function($scope, $timeout){
        var updateClock = function() {
            $scope.clock = new Date();
            $timeout(function() {
                updateClock();
            }, 1000);
        };
        updateClock();
    }]);
```

> 在这个例子中， MyController函数接受两个参数，即该DOM元素的`$scope`和
`$timeout`。

当定时器触发时会调用`updateClock()`函数，将`$scope.clock`的值设置为当
前时间。

可以在视图中将clock变量用`{{ }}`包起来，以显示$scope中的clock的值：

```html
<div ng-controller="MyController">
    <h5>{{ clock }}</h5>
</div>
```

下面是完整的代码：

```html
<!doctype html>
<html ng-app="app">
<head>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.2.13/angular.js"></script>
</head>
<body>
<div ng-controller="MyController">
    <h1>Hello {{ clock }}!</h1>
</div>
<script type="text/javascript">
     angular.module('app',[])
    .controller('MyController', ['$scope','$timeout', function($scope, $timeout){
        var updateClock = function() {
            $scope.clock = new Date();
            $timeout(function() {
                updateClock();
            }, 1000);
        };
        updateClock();
    }]);
</script>
</body>
</html>
```

<iframe frameborder="0" width="100%" src="partial/notes/angular/iframe/1.1.2.html">
</iframe>

## 3.数据绑定的最佳实践

由于JavaScript自身的特点，以及它在传递值和引用时的不同处理方式，通常认为，在视图中
通过对象的属性而非对象本身来进行引用绑定，是Angular中的最佳实践。

如果把这个最佳实践应用到上面时钟的例子中，需要把视图中的代码改写成下面这样：

```html
 <!doctype html>
<html ng-app>
<head>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.2.13/angular.js"></script>
</head>
<body>
    <div ng-controller="MyController">
        <h1>Hello {{ clock.now }}!</h1>
    </div>
    <script type="text/javascript" src="js/app.js"></script>
</body>
</html>
```

在这个例子中，相比每秒钟都更新`$scope.clock`，更新`clock.now`的值会是更好的选择。有
了这个优化后，我们将反映数据变化的逻辑做如下修改：

```js
// 在app.js中
 angular.module('app',[])
    .controller('MyController', ['$scope','$timeout', function($scope, $timeout){
       $scope.clock = {
        now : new Date()
       };
       var updateClock = function() {
            $scope.clock.now = new Date()
        };
        setInterval(function() {
            $scope.$apply(updateClock);
        }, 1000);
        updateClock()
    }]);
```

> `$scope.$apply(fn)` 执行fn函数 更新$scope数据。如果我们需要在一个新的执行序列中运行代码，而且当且仅当这个新的执行序列不是被angular JS的库的方法创建的，这个时候我们需要将代码用scope.apply()包起来。
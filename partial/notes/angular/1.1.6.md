## 过滤器

<br>
过滤器用来格式化需要展示给用户的数据。在HTML中的模板绑定符号{{ }}内通过|符号来调用过滤器。例如，假设我们希望将字符串
转换成大写，可以对字符串中的每个字符都单独进行转换操作，也可以使用过滤器：

```html
    {{ name | uppercase }}
```


在JavaScript代码中可以通过`$filter`来调用过滤器。例如，在JavaScript代码中使用`lowercase`过滤器：

```js
app.controller('DemoController', ['$scope', '$filter',
    function($scope, $filter) {
        $scope.name = $filter('lowercase')('Ari');
}]);
```

以HTML的形式使用过滤器时，如果需要传递参数给过滤器，只要在过滤器名字后面加冒号
即可。如果有多个参数，可以在每个参数后面都加入冒号。例如，数值过滤器可以限制小数点后的位数，在过滤器后写上:2可以将2作为参数传给过滤器：

```html
<!-- 显示： 123.46 -->
{{ 123.456789 | number:2 }}
```

可以用|符号作为分割符来同时使用多个过滤器。

AngularJS提供的内置过滤器:

1. **currency**

 currecy过滤器可以将一个数值格式化为货币格式。用`{{ 123 | currency }}`来将123转化成货币格式。

 currecy过滤器允许我们自己设置货币符号。默认情况下会采用客户端所处区域的货币符号，但是也可以自定义货币符号。

2. **date** 
 
 date过滤器可以将日期格式化成需要的格式。 AngularJS中内置了几种日期格式，如果没有指定使用任何格式，默认会采用mediumDate格式。下面是内置的支持本地化的日期格式：
 ```html
{{ today | date:'medium' }} <!-- Aug 09, 2013 12:09:02 PM -->
{{ today | date:'short' }} <!-- 8/9/1312:09PM -->
{{ today | date:'fullDate' }} <!-- Thursday, August 09, 2013 -->
{{ today | date:'longDate' }} <!-- August 09, 2013 -->
{{ today | date:'mediumDate' }}<!-- Aug 09, 2013 -->
{{ today | date:'shortDate' }} <!-- 8/9/13 -->
{{ today | date:'mediumTime' }}<!-- 12:09:02 PM -->
{{ today | date:'shortTime' }} <!-- 12:09 PM -->
 ```
 · 年份格式化
```html
四位年份： {{ today | date:'yyyy' }} <!-- 2013 -->
两位年份： {{ today | date:'yy' }} <!-- 13 -->
一位年份： {{ today | date:'y' }} <!-- 2013 -->
```
 ·月份格式化
```html
英文月份： {{ today | date:'MMMM' }} <!-- August -->
英文月份简写： {{ today | date:'MMM' }} <!-- Aug -->
数字月份： {{ today |date:'MM' }} <!-- 08 -->
一年中的第几个月份： {{ today |date:'M' }} <!-- 8 -->
```
 ·日期格式化
```html
数字日期： {{ today|date:'dd' }} <!-- 09 -->
一个月中的第几天： {{ today | date:'d' }} <!-- 9 -->
英文星期： {{ today | date:'EEEE' }} <!-- Thursday -->
英文星期简写： {{ today | date:'EEE' }} <!-- Thu -->
```
 ·小时格式化
```html
24小时制数字小时： {{today|date:'HH'}} <!--00-->
一天中的第几个小时： {{today|date:'H'}} <!--0-->
12小时制数字小时： {{today|date:'hh'}} <!--12-->
上午或下午的第几个小时： {{today|date:'h'}} <!--12-->
```
 ·分钟格式化
```html
数字分钟数： {{ today | date:'mm' }} <!-- 09 -->
一个小时中的第几分钟： {{ today | date:'m' }} <!-- 9 -->
```
 ·秒数格式化
```html
数字秒数： {{ today | date:'ss' }} <!-- 02 -->
一分钟内的第几秒： {{ today | date:'s' }} <!-- 2 -->
毫秒数： {{ today | date:'.sss' }} <!-- .995 -->
```
 ·字符格式化
```html
上下午标识： {{ today | date:'a' }} <!-- AM -->
四位时区标识： {{ today | date:'Z' }} <!--- 0700 -->
```
 下面是一些自定义日期格式的示例：
```html
{{ today | date:'MMMd, y' }} <!-- Aug9, 2013 -->
{{ today | date:'EEEE, d, M' }} <!-- Thursday, 9, 8-->
{{ today | date:'yyyy-MM-dd HH:mm:ss:sss EEEE' }} <!-- 2017-03-21 09:28:02:967 -->
```

3. **filter**

 从给定数组中选择一个子集，并将其生成一个新数组返回。第一个参数可以是字符串、对象或是一个用来从数组中选择元素的函数。
 - 字符串
     + 返回所有包含这个字符串的元素。如果我们想返回不包含该字符串的元素，在参数前加!符号。
 - 对象
     + AngularJS会将待过滤对象的属性同这个对象中的同名属性进行比较，如果属性值是字符串就会判断是否包含该字符串。如果我们希望对全部属性都进行对比，可以将`$`当作键名。
 - 函数
     + 对每个元素都执行这个函数，返回非假值的元素会出现在新的数组中并返回。
 
 我们也可以给filter过滤器传入第二个参数，用来指定预期值同实际值进行比较的方式。第二个参数可以是以下三种情况之一:
 - **true**
     + 用angular.equals(expected, actual)对两个值进行严格比较。
 - **false**
     + 进行区分大小写的子字符串比较。
 - **函数**
     + 运行这个函数，如果返回真值就接受这个元素。

4. **json**
 
 json过滤器可以将一个JSON或JavaScript对象转换成字符串。

5. **limitTo**
 
 limitTo过滤器会根据传入的参数生成一个新的数组或字符串，新的数组或字符串的长度取决于传入的参数，通过传入参数的正负值来控制从前面还是从后面开始截取。
 > 如果传入的长度值大于被操作数组或字符串的长度，那么整个数组或字符串都会被
返回。
6. **lowercase**
 
 lowercase过滤器将字符串转为小写。
7. **number**
 
 number过滤器将数字格式化成文本。它的第二个参数是可选的，用来控制小数点后截取的位数。
 > 如果传入了一个非数字字符，会返会空字符串。
8. **orderBy**
 
 orderBy过滤器可以用表达式对指定的数组进行排序。
 orderBy可以接受两个参数，第一个是必需的，第二个是可选的。

 第一个参数是用来确定数组排序方向的谓词。
 - **函数**
     + 当第一个参数是函数时，该函数会被当作待排序对象的getter方法。
 - **字符串**
     + 对这个字符串进行解析的结果将决定数组元素的排序方向。我们可以传入+或-来强制进行升序或降序排列。
 - **数组**
     + 在排序表达式中使用数组元素作为谓词。对于与表达式结果并不严格相等的每个元素，则使用第一个谓词。

 第二个参数用来控制排序的方向（是否逆向）。
 - **true**
     + 逆向排序
9. **uppercase**
 
 uppercase过滤器可以将字符串转换为大写形式：


### 自定义过滤器

创建自定义过滤器需要将它放在自己的模块中，然后在应用中引用。下面实现一个过滤器，将字符串第一个字母转换为大写。

首先，创建一个模块用以在应用中进行引用
```js
angular.module('myApp.filters', [])
    .filter('capitalize', function() {
    return function(input) {
        //input是我们传入的字符串
        if(input){
            return input[0].toUpperCase() + input.slice(1);
        }
    };
});
```

过滤器本质上是一个会把我们输入的内容当作参数传入进去的函数

### 表单验证

要使用表单验证，首先要确保表单有一个name属性。所有输入字段都可以进行基本的验证，比如最大、最小长度等。这些功能是由新的HTML5表单属性提供的。如果想要屏蔽浏览器对表单的默认验证行为，可以在表单元素上添加novalidate标记。

#### 在input元素上使用的所有验证选项。

1. **必填项**
 
 验证某个表单输入是否已填写，只要在输入字段元素上添加HTML5标记required即可：

2. **最小长度**
 
 验证表单输入的文本长度是否大于某个最小值，在输入字段上使用AngularJS指令`ng-minleng="{number}"`

3. **最大长度**
 
 验证表单输入的文本长度是否小于或等于某个最大值，在输入字段上使用AngularJS指令
`ng-maxlength="{number}"`：

4. **匹配模式**
 
 使用`ng-pattern="/PATTERN/"`来确保输入能够匹配指定的正则表达式：
 ```html
 <input type="text" ng-pattern="[a-zA-Z]" />
 ```

5. **电子邮件**
 
 验证输入内容是否是电子邮件，只要像下面这样将input的类型设置为email即可：
 ```html
<input type="email" name="email" ng-model="user.email" />
 ```
 
6. **数字**
 
 验证输入内容是否是数字，将input的类型设置为number

7. **URL**
 
 验证输入内容是否是URL，将input的类型设置为 url：

8. **自定义验证**
 
 后面自定义指令中介绍

9. 在表单中控制变量
 
 表单的属性可以在其所属的`$scope`对象中访问到，而我们又可以访问`$scope`对象，因此JavaScript可以间接地访问DOM中的表单属性。借助这些属性，我们可以对表单做出实时（和AngularJS中其他东西一样）响应。这些属性包括下面这些。

 可以使用下面的格式访问这些属性:
 ```
 formName.inputFieldName.property
 ```

 - **未修改的表单**
    + 这是一个布尔属性，用来判断用户是否修改了表单。如果未修改，值为`true`，如果修改过值为`false`：
     ```
     formName.inputFieldName.$pristine
     ```

 - **修改过的表单**
    + 只要用户修改过表单，无论输入是否通过验证，该值都返回`true`：
    ```
        formName.inputFieldName.$dirty
    ```

 - **合法的表单**
    + 这个布尔型的属性用来判断表单的内容是否合法。如果当前表单内容是合法的，下面属性的值就是`true`：
    ```
    formName.inputFieldName.$valid
    ```

 - **不合法的表单**
    + 这个布尔属性用来判断表单的内容是否不合法。如果当前表单内容是不合法的，下面属性的值为`true`：
    ```
    formName.inputFieldName.$invalid
    ```

 - **错误**
    + 这是AngularJS提供的另外一个非常有用的属性： `$error`对象。它包含当前表单的所有验证内容，以及它们是否合法的信息。用下面的语法访问这个属性：
    ```
    formName.inputfieldName.$error
    ```
    如果验证失败，这个属性的值为true；如果值为false，说明输入字段的值通过了验证。

10. **一些有用的CSS样式**
 
 AngularJS处理表单时，会根据表单当前的状态添加一些CSS类（例如当前是合法的、未发生变化的，等等），这些CSS类的命名和前面介绍的属性很相似。

 ```css
.ng-pristine {}
.ng-dirty {}
.ng-valid {}
.ng-invalid {}
 ```
 
 它们对应着表单输入字段的特定状态。
 当某个字段中的输入非法时， `.ng-invlid`类会被添加到这个字段上。

· **$parsers**

当用户同控制器进行交互，并且`ngModelController`中的`$setViewValue()`方法被调用时，`$parsers`数组中的函数会以流水线的形式被逐个调用。第一个`$parse`被调用后，执行结果会传递给第二个`$parse`，以此类推。

这些函数可以对输入值进行转换，或者通过`$setValidity()`函数设置表单的合法性。
使用`$parsers`数组是实现自定义验证的途径之一。例如，假设我们想要确保输入值在某两个数值之间，可以在`$parsers`数组中入栈一个新的函数，这个函数会在验证链中被调用。

每个`$parser`返回的值都会被传入下一个`$parser`中。当不希望数据模型发生更新时返回`undefined`。

```
angular.module('myApp')
    .directive('oneToTen', function() {
        return {
            require: '?ngModel',
            link: function(scope, ele, attrs, ngModel) {
                if (!ngModel) return;
                ngModel.$parsers.unshift(
                function(viewValue) {
                    var i = parseInt(viewValue);

                    if (i >= 0 && i < 10) {
                        ngModel.$setValidity('oneToTen', true);
                        return viewValue;
                    } else {
                        ngModel.$setValidity('oneToTen', false);
                        return undefined;
                    }
                });
            }
        };
    });
```


· **$formatters**

当绑定的ngModel值发生了变化，并经过`$parsers`数组中解析器的处理后，这个值会被传递
给`$formatters`流水线。同`$parsers`数组可以修改表单的合法性状态类似，`$formatters`中的函数也可以修改并格式化这些值。

比起单纯的验证目的，这些函数更常用来处理视图中的可视变化。例如，假设我们要对某个值进行格式化。通过`$formatters`数组可以在这个值上执行过滤器：

```
angular.module('myApp')
    .directive('oneToTen', function() {
        return {
            require: '?ngModel',
            link: function(scope, ele, attrs, ngModel) {
                if (!ngModel) return;
                    ngModel.$formatters.unshift(function(v) {
                    return $filter('number')(v);
                });
            }
        };
    });
```


### 组合实例

创建一个注册表单。表单中包括用户的名字、邮件地址以及用户名。

```html
<form name="signup_form" novalidateng-submit="signupForm()">
    <fieldset>
        <legend>Signup</legend>
        <button type="submit" class="button radius">Submit</button>
    </fieldset>
</form>
```

下面添加用户的名字：

```html
<div class="row">
    <div class="large-12 columns">
        <label>Your name</label>
        <input type="text"
        placeholder="Name"
        name="name"
        ng-model="signup.name"
        ng-minlength="3"
        ng-maxlength="20" required />
    </div>
</div>
```

我们添加了一个表单，这个表单有一个名为`name`的输入字段，并且这个输入字段被`ng-model`指令绑定到了`$scope`对象的`signup.name`上。

*不要忘记给输入字段添加name属性。给输入字段添加name属性非常重要：这决
定了我们将验证信息展示给用户时如何引用表单输入字段。*

同时，我们也设置了一些验证。验证要求`name`字段的最小长度是3个字符，最大长度是20个字符（当长度大于等于21时输入会变为不合法）。最后，我们要求`name`字段是必填项。

通过使用这些属性，可以在表单未通过验证时控制展示或隐藏错误列表。用`$dirty`属性来确保用户未对输入内容进行修改时错误内容不会显示出来：

```html
<div class="row">
    <div class="large-12 columns">
        <label>Your name</label>
            <input type="text"
            placeholder="Name"
            name="name"
            ng-model="signup.name"
            ng-minlength="3"
            ng-maxlength="20" required />
        <div class="error"
        ng-show="signup_form.name.$dirty && signup_form.name.$invalid">
            <small class="error"
            ng-show="signup_form.name.$error.required">
                Your name is required.
            </small>
            <small class="error"
            ng-show="signup_form.name.$error.minlength">
                Your name is required to be at least 3 characters
            </small>
            <small class="error"
            ng-show="signup_form.name.$error.maxlength">
                Your name cannot be longer than 20 characters
            </small>
        </div>
    </div>
</div>
```

将整个过程分开来看，我们只是像以前一样在表单发生改变，且输入内容不合法时才展示错误内容。现在，我们会在特定的属性未通过验证时只展示对应的特定DOM元素。

接下来看下一组验证，电子邮箱的验证：

```html
<div class="row">
    <div class="large-12 columns">
        <label>Your email</label>
        <input type="email"
        placeholder="Email"
        name="email"
        ng-model="signup.email"
        ng-minlength="3" ng-maxlength="20" required />
        <div class="error"
        ng-show="signup_form.email.$dirty && signup_form.email.$invalid">
            <small class="error"
            ng-show="signup_form.email.$error.required">
                Your email is required.
            </small>
            <small class="error"
            ng-show="signup_form.email.$error.minlength">
                Your email is required to be at least 3 characters
            </small>
            <small class="error"
            ng-show="signup_form.email.$error.email">
                That is not a valid email. Please input a valid email.
            </small>
            <small class="error"
            ng-show="signup_form.email.$error.maxlength">
                Your email cannot be longer than 20 characters
            </small>
        </div>
    </div>
</div>
```

现在整个表单都被包含进来了，我们来看一下电子邮件的输入字段。注意，我们将输入字段的type属性设置为email，并且在`$error.email`上添加了验证错误的信息。这个验证同时基于AngularJS和HTML5属性实现。

最后，看一下用户名的输入字段：

```html
<div class="large-12 columns">
    <label>Username</label>
    <input type="text"
        placeholder="Desired username"
        name="username"
        ng-model="signup.username"
        ng-minlength="3"
        ng-maxlength="20"
        ensure-unique="username" required />
    <div class="error"
    ng-show="signup_form.username.$dirty &&
        signup_form.username.$invalid">
        <small class="error"
        ng-show="signup_form.username.$error.required">
            Please input a username
        </small>
        <small class="error"
        ng-show="signup_form.username.$error.minlength">
            Your username is required to be at least 3 characters
        </small>
        <small class="error"
        ng-show="signup_form.username.$error.maxlength">
            Your username cannot be longer than 20 characters
        </small>
        <small class="error"
        ng-show="signup_form.username.$error.unique">
            That username is taken, please try another
        </small>
    </div>
</div>
```

在最后一个输入字段中除了同前面相同的验证外，还添加了一个自定义验证。这个自定义验证是用AngularJS指令定义的：

```js
app.directive('ensureUnique', function($http) {
    return {
        require: 'ngModel',
    link: function(scope, ele, attrs, c) {
            scope.$watch(attrs.ngModel, function(n) {
                if (!n) return;
                $http({
                    method: 'POST',
                    url: '/api/check/' + attrs.ensureUnique,
                    data: {
                        field: attrs.ensureUnique,
                        value: scope.ngModel
                    }
                }).success(function(data) {
                    c.$setValidity('unique', data.isUnique);
                }).error(function(data) {
                    c.$setValidity('unique', false);
                });
            });
        }
    };
});

```

最后，把按钮放进去。可以用ng-disabled指令基于表单的合法性来启用或禁用按钮：

```html
    <button type="submit"
            ng-disabled="signup_form.$invalid"
            class="button radius">Submit</button>
```


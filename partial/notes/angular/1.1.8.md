## 指令：自定义 HTML 元素和属性

指令本质上就是AngularJS扩展具有自定义功能的HTML元素的途径。

在HTML中要用内置指令ng-app标记出应用的根节点。这个指令需要以属性的形式来使用，
因此可以将它写到任何位置，但是写到<html>的开始标签上是最常规的做法

*内置指令是打包在AngularJS内部的指令。所有内置指令的命名空间都使用ng作
为前缀。为了防止命名空间冲突，不要在自定义指令前加ng前缀。*

基于JavaScript的原型继承机制，任何在这个根元素内部的指令只要能够访问作用域，就可以访问`$rootScope`。这里的能够访问作用域指的是同DOM进行了链接，这个操作会在指令稍后的生命周期中进行。

### 第一个指令

```
    <my-directive></my-directive>
    <script>
        var app = angular.module('app', [])

        app.directive('myDirective',function () {
            return {
                restrict:'E',
                template:'<a href="http://google.com">Click me to go to Google</a>'
            }
        })
    </script>
```
上面的JavaScript代码就是指令定义，效果下所示。

<iframe frameborder="0" width="100%" src="partial/notes/angular/iframe/1.1.8.1.html">
</iframe>

通过AngularJS模块API中的`.directive()`方法，我们可以通过传入一个字符串和一个函数来注册一个新指令。其中字符串是这个指令的名字，指令名应该是驼峰命名风格的，函数应该返回一个对象。

*驼峰命名风格用来将一个短语写在一个单词中，除了第一个单词外其他单词首
字母大写，中间不加空格。例如， bumpy roads用驼峰风格来写应该是bumpyRoads。*

*在HTML里使用my-directive声明指令，因此指令定义必须以myDirective为名字。*

下面向指令定义中添加一些新的设置：我们可以将自定义标签从生成的DOM中完全移除掉，
并只留下由模版生成的链接。将replace设置为true就可以实现这个效果：

```
var app = angular.module('app', [])

        app.directive('myDirective',function () {
            return {
                restrict:'E',
                replace:true,
                template:'<a href="http://google.com">Click me to go to Google</a>'
            }
        })
```

我们把创建的这些自定义元素称作指令（用.directive()方法创建），因为事实
上声明指令并不需要创建一个新的自定义元素。

*声明指令本质上是在HTML中通过元素、属性、类或注释来添加功能。*

下面都是用来声明前面创建指令的合法格式：

```
<my-directive></my-directive>
<div my-directive></div>
<div class="my-directive"></div>
<!--directive:my-directive-->
```

为了让AngularJS能够调用我们的指令，需要修改指令定义中的restrict设置。这个设置告
诉AngularJS在编译HTML时用哪种声明格式来匹配指令定义。我们可以指定一个或多个格式。

例如，之前创建的指令中可以指定以元素（E） 、属性（A） 、类（C）或注释（M）的格式来调用指令：

```

        app.directive('myDirective',function () {
            return {
                restrict:'EAC',
                replace:true,
                template:'<a href="http://google.com">Click me to go to Google</a>'
            }
        })
```

无论有多少种方式可以声明指令，我们坚持使用属性方式，因为它有比较好的跨浏览器兼容性

###  表达式

```
<h1 ng-init="greeting='HelloWorld'">
    The greeting is: {{ greeting }}
</h1>
```

我们将表达式`greeting = 'Hello World'`赋值给内置指令`ng-init`。在表达式中，我们将`greeting`属性的值设置为`Hello World`，然后计算花括号内的`{{ greeting }}`这个表达式的值。

这两种情况都会在当前作用域中计算一个普通的JavaScript表达式。根据这个表达式放置的位置不同，当前作用域可以是AngularJS在应用启动时调用ng-app实例化的$rootScope，也可以是某个子作用域，比如某个控制器的作用域。


### 用表达式来声明指令

声明指令时既可以使用表达式，也可以不使用表达式。几种合法的表
达式声明：

```
<my-directive="someExpression">
</my-directive>
<div my-directive="someExpression">
</div>
<div class="my-directive:someExpression">
</div>
<!-- directive: my-directive someExpression -->
```

这里有一个值得注意的问题，赋值给指令的表达式会在哪个环境中运行？要回答这个问题，首先要了解一个复杂但非常重要的概念，就是当前作用域，它由DOM周围嵌套的控制器提供。

### 当前作用域

```
<p>We can access: {{ rootProperty }}</p>

<div ng-controller="ParentController">
    <p>We can access: {{ rootProperty }} and {{ parentProperty }}</p>
    <div ng-controller="ChildController">
        <p>
        We can access:
        {{ rootProperty }} and
        {{ parentProperty }} and
        {{ childProperty }}
        </p>
        <p>{{ fullSentenceFromChild }}</p>
    </div>
</div>
```

```
angular.module('myApp', [])
    .run(function($rootScope) {
        // 使用.run访问$rootScope
        $rootScope.rootProperty = 'root scope';
    })
    .controller('ParentController', function($scope) {
        // 使用.controller访问`ng-controller`内部的属性
        // 在DOM忽略的$scope中，根据当前控制器进行推断
        $scope.parentProperty = 'parent scope';
    })
    .controller('ChildController', function($scope) {
        $scope.childProperty = 'child scope';
        // 同在DOM中一样，我们可以通过当前$scope直接访问原型中的任意属性
        $scope.fullSentenceFromChild = 'Same $scope: We can access: ' +
        $scope.rootProperty + ' and ' +
        $scope.parentProperty + ' and ' +
        $scope.childProperty
    });
```


## 向指令传递数据

```
angular.module('myApp', [])
.directive('myDirective', function() {
    return {
        restrict: 'A',
        replace: true,
        template: '<a href="http://google.com">Click me to go to Google</a>'
    }
});
```

可以将上面的模板转换成可以接受两个变量的形式：一个变量是URL，另一个是链接文本：

```
template: '<a href="{{ myUrl }}">{{ myLinkText }}</a>'
```

在主HTML文档中，可以给指令添加myUrl和myLinkText两个属性，这两个参数会成为指令内部作用域的属性：

```
<div my-directive
    my-url="http://google.com"
    my-link-text="Click me to go to Google">
</div>

```

有好几种途径可以设置指令内部作用域中属性的值。最简单的方法就是使用由所属控制器提供的已经存在的作用域。

尽管简单，共享状态会导致很多其他问题。如果控制器被移除，或者在控制器的作用域中也定义了一个叫myUrl的属性，我们就被迫要修改代码，这是成本很高且让人沮丧的事情。

AngularJS允许通过创建新的子作用域或者隔离作用域来解决这个常见问题。

*同之前在当前作用域介绍中介绍的继承作用域（子作用域）不同，隔离作用域同当
前DOM的作用域是完全分隔开的。为了给这个新的对象设置属性，我们需要显式地通
过属性传递数据，同在JavaScript或Ruby中给方法传递参数类似。*

```
<div my-directive
    my-url="http://google.com"
    my-link-text="Click me to go to Google"></div>
```

```
angular.module('myApp', [])
    .directive('myDirective', function() {
        return {
            restrict: 'A',
            replace: true,
            scope: {
                myUrl: '@', //绑定策略
                myLinkText: '@' //绑定策略
            },
            template: '<a href="{{myUrl}}">' +
                      '{{myLinkText}}</a>'
        };
    });
```

scope 是指令myDirective的私有作用域，属性myUrl、myLinkText分别对应DOM中my-url、y-link-text的值。

由于作用域中属性经常是私有的，因此可以（虽然不常见）指定我们希望将这个内部属性同哪个DOM属性进行绑定：

```
scope: {
    myUrl: '@someAttr',
    myLinkText: '@'
}

```

上面的隔离作用域中的内容是：将指令的私有属性$scope.myUrl同DOM中some-attr属性
的值绑定起来。这个值既可以是硬编码的也可以是当前作用域（例如Some-attr="{{expression}}）中某个表达式的运算结果。

还可以在DOM对应的作用域上运算表达式，并将结果传递给指令，在指令内部最终被绑定在属性上：

```
<div my-directive
    some-attr="{{ 'http://' + 'google.com' }}">
</div>
```

创建一个文本输入域，并将输入值同指令内部隔离作用域的属性绑定起来：

```
<input type="text" ng-model="myUrl" />
<div my-directive
    some-attr="{{ myUrl }}"
    my-link-text="Click me to go to Google">
</div
```

这段代码是可以工作的，但如果我们将文本输入字段移到指令内部并在另一个指令中进行绑定，就无法正常工作了：

```
<div my-directivesome-attr="{{ myUrl }}"
    my-link-text="Click me to go to Google">
</div>
```

```
template: '<div>\
            <input type="text" ng-model="myUrl" />\
            <a href="{{myUrl}}">{{myLinkText}}</a>\
        </div>'
```


双向数据绑定或许是AngularJS中最重要且无法通过jQuery简单实现的功能之一。我们需要自己实现它进而了解它的神奇效果，幸好，所需工作并不多。接下来在我们的隔离作用域和`ng-model`内 部 的 隔 离 作 用 域 之 间 创 建 一 个 双 向 数 据 绑 定 ， 这 样 我 们 的 例 子 就 完 整 了 。 将 内部 的`$scope.myUrl属性同当前控制器作用域中的theirUrl属性进行绑定，在DOM中通过作用域查询来实现这个绑定。

在这个流程中，给两个方向的绑定都添加一个文本输入字段。通过这两个输入字段可以方便地观察作用域是如何在DOM中通过原型继承链接在一起的：

```
<input type="text" ng-model="myUrl" />
    <div my-directive
        some-attr="myUrl"
        my-link-text="Click me to go to Google">
    </div>
    
    <script>
        var app = angular.module('app', []);

        app.directive('myDirective',function () {
            return{
                restrict:'A',
                replace:true,
                scope:{
                    myUrl:'=someAttr',
                    myLinkText:'@'
                },
                template:'\
                    <div>\
                    <label>My Url Field:</label>\
                    <input type="text"\
                    ng-model="myUrl" />\
                    <a href="{{myUrl}}">{{myLinkText}}</a>\
                    </div>'
            }
        })
    </script>
```

<iframe frameborder="0" width="100%" src="partial/notes/angular/iframe/1.1.8.2.html">
</iframe>
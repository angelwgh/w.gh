## 表达式

用`{{ }}`符号将一个变量绑定到`$scope`上的写法本质上就
是一个表达式： `{{ expression }}`。当用`$watch`进行监听时， AngularJS会对表达式或函数进行运算。

表达式和`eval(javascript)`非常相似，但是由于表达式由AngularJS来处理，它们有以下显著不同的特性：

-  所有的表达式都在其所属的作用域内部执行，并有访问本地`$scope`的权限；
-如果表达式发生了`TypeError`和`ReferenceError`并不会抛出异常；
-不允许使用任何流程控制功能（条件控制，例如if/eles）；
-可以接受过滤器和过滤器链

对表达式进行的任何操作，都会在其所属的作用域内部执行，因此可以在表达式内部调用那些限制在此作用域内的变量，并进行循环、函数调用、将变量应用到数学表达式中等操作。


### 解析AngularJS表达式

AngularJS通过`$parse`这个内部服务来进行表达式的运算，这个服务能够访问当前所处的作
用域。这个过程允许我们访问定义在`$scope`上的原始JavaScript数据和函数。

将`$parse`服务注入到控制器中，然后调用它就可以实现手动解析表达式。举例来说，如果页
面上有一个输入框绑定到了`expr`变量上，如下所示：

```html
<div ng-controller="MyController">
    <input ng-model="expr"
            type="text"
            placeholder="Enter an expression" />
    <h2>{{ parseValue }}</h2>
</div>
```

我们可以在MyController中给expr这个表达式设置一个`$watch`并解析它：

```js
angular.module("myApp", [])
.controller('MyController',
    function($scope,$parse) {
        $scope.$watch('expr', function(newVal, oldVal, scope) {
            if (newVal !== oldVal) {
            // 用该表达式设置parseFun
            var parseFun = $parse(newVal);
            // 获取经过解析后表达式的值
            $scope.parseValue = parseFun(scope);
        }
    });
});
```

<iframe frameborder="0" width="100%" src="partial/notes/angular/iframe/1.1.5.1.html">
</iframe>


### 插值字符串

要在字符串模板中做插值操作，需要在你的对象中注入`$interpolate`服务。在下面的例子
中，我们将会将它注入到一个控制器中：

```
angular.module('myApp', [])
    .controller('MyController',
    function($scope, $interpolate) {
    // 我们同时拥有访问$scope和$interpolate服务的权限
    });
```

`$interpolate`服务是一个可以接受三个参数的函数，其中第一个参数是必需的。

- `text`（字符串）：一个包含字符插值标记的字符串。
- `mustHaveExpression`（布尔型）：如果将这个参数设为`true`，当传入的字符串中不含有表
达式时会返回`null`。
- `trustedContext`（字符串）： AngularJS会对已经进行过字符插值操作的字符串通过
`$sec.getTrusted()`方法进行严格的上下文转义。


`$interpolate`服务返回一个函数，用来在特定的上下文中运算表达式

设置好这些参数后，就可以在控制器中进行字符插值的操作了。例如，假设我们希望可以在电子邮件的正文中进行实时编辑，当文本发生变化时进行字符插值操作并将结果展示出来。

```html
<div ng-controller="MyController">
    <input ng-model="to"
    type="email"
    placeholder="Recipient" />
    <textarea ng-model="emailBody"></textarea>
    <pre>{{ previewText }}</pre>
</div>
```

由于控制器内部设置了一个需要每次变化都重新进行字符插值的自定义输入字段，因此需要设置一个`$watch`来监听数据的变化。

在控制器中，我们设置了`$watch`来监视邮件正文的变化，并将`emailBody`属性的值进行字符
插值后的结果赋值给`previewText`属性。

```js
angular.module('app',[])
    .controller('MyController', ['$scope','$interpolate', 
        function($scope, $interpolate){
            //监听emailBody
            $scope.$watch('emailBody', function(body) {
                if(body){
                    //解析 body
                    var template = $interpolate(body);

                    //把$scope.to的值插入到body中{{to}}的位置
                    $scope.previewText = 
                    template({to:$scope.to});
                }
                
            });
        }
    ]);

```

现在，在`{{ previewText }}`内部的文本中可以将`{{ to }}`当做一个变量来使用，并对文本
的变化进行实时更新。
<iframe frameborder="0" width="100%" src="partial/notes/angular/iframe/1.1.5.2.html">
</iframe>

如果需要在文本中使用不同于`{{ }}`的符号来标识表达式的开始和结束，可以在
`$inter polateProvider`中配置

- 用`startSymbol()`方法可以修改标识开始的符号。这个方法接受一个参数。
    + `value`（字符型） ：开始符号的值。
- 用`endSymbol()`方法可以修改标识结束的符号。这个方法也接受一个参数。
    + `value`（字符型） ：结束符号的值。

如果要修改这两个符号的设置，需要在创建新模块时将`$interpolateProvider`注入进去。


```js
angular.module('emailParser', [])
    .config(['$interpolateProvider', function($interpolateProvider) {
        $interpolateProvider.startSymbol('__');
        $interpolateProvider.endSymbol('__');
    }])
    .factory('EmailParser', ['$interpolate', function($interpolate) {
    // 处理解析的服务
        return {
            parse: function(text, context) {
                var template = $interpolate(text);
                return template(context);
            }
        };
    }]);

```

现在，我们已经创建了一个模块，可以将它注入到应用中，并在邮件正文的文本中运行这个邮件解析器：

```js
angular.module('myApp', ['emailParser'])
    .controller('MyController', ['$scope', 'EmailParser',
        function($scope, EmailParser) {
        // 设置监听
            $scope.$watch('emailBody', function(body) {
                if (body) {
                $scope.previewText = EmailParser.parse(body, {
                    to: $scope.to
                });
            }
        });
    }]);
```

现在用自定义的 `__ `符号取代默认语法中的 `{{ }}` 符号来请求插值文本。

由于我们将表达式开始和结束的符号都设置成了`__`，因此需要将HTML修改成用这个符号取
代`{{ }}`的版本，效果如图6-1所示。

```html
<div id="emailEditor">
    <input ng-model="to"
    type="email"
    placeholder="Recipient" />
    <textarea ng-model="emailBody"></textarea>
</div>
<div id="emailPreview">
    <pre>__ previewText __</pre>
</div>
```

## 指令定义

```
angular.module('myApp', [])
    .directive('myDirective', function ($timeout, UserDefinedService) {
    // 指令定义放在这里
        return {
        // 通过设置项来定义指令，在这里进行覆写
        };
    });
```

`directive()` 方法可以接受两个参数：
1. name（字符串）
 指令的名字，用来在视图中引用特定的指令。
2. factory_function （函数）
 这个函数返回一个对象，其中定义了指令的全部行为。 `$compile`服务利用这个方法返回的对象，在DOM调用指令时来构造指令的行为

```
angular.module('myApp', [])
    .directive('myDirective', function ($timeout, UserDefinedService) {
    // 指令定义放在这里
        return {
            restrict: String, //指令声明形式
            priority: Number, //指令优先级
            terminal: Boolean, //停止运行当前元素上比本指令优先级低的指令。
            template: String or Template Function:  //html模板
            function(tElement, tAttrs) {...},
            templateUrl: String,                     //html模板地址
            replace: Boolean or String,            //模板是否替换调用指令的元素
            scope: Boolean or Object,              //作用域
            transclude: Boolean,                   //
            controller: String or
                function(scope, element, attrs, transclude, otherInjectables) { ... },
            controllerAs: String,
            require: String,
            link: function(scope, iElement, iAttrs) { ... },
            compile: // 返回一个对象或连接函数，如下所示：
                function(tElement, tAttrs, transclude) {
                    return {
                        pre: function(scope, iElement, iAttrs, controller) { ... },
                        post: function(scope, iElement, iAttrs, controller) { ... }
                    }
                    // 或者
                    return function postLink(...) { ... }
                }
        };
    });
```

1. **restrict**（字符串）
 
 restrict是一个可选的参数。它告诉AngularJS这个指令在DOM中可以何种形式被声明。默
认AngularJS认为restrict的值是A，即以属性的形式来进行声明。

    *E（元素）*
    ```
    <my-directive></my-directive>
    ```
    *A（属性，默认值）*
    ```
    <div my-directive="expression"></div>
    ```
   *C（类名）*
    ```
    <div class="my-directive:expression;"></div>
    ```
   *M（注释）*
    ```
    <--directive:my-directive expression-->
    ```

    这些选项可以单独使用，也可以混合在一起使用：
    ```
    angular.module('myDirective', function(){
        return {
            restrict: 'EA' // 输入元素或属性
        };
    });
    ```

2. **priority** (数值)
 
 优先级，可以被设置为一个数值。大多数指令会忽略这个参数，使用默认值0。如果一个元素上具有两个优先级相同的指令，声明在前面的那个会被优先调用。如果其中一个的优先级更高，则不管声明的顺序如何都会被优先调用：具有更高优先级的指令总是优先运行。

 *ngRepeat是所有内置指令中优先级最高的，它总是在其他指令之前运行。*

3. **terminal** (布尔型)

 个参数用来告诉AngularJS停止运行当前元素上比本指令优先级低的指令。但同当前指令优先级相同的指令还是会被执行。

4. **template**（字符串或函数）
 
 模板字符串，参数是可选的，必须被设置为以下两种形式之一：
 - 一段HTML文本；
 -  一个可以接受两个参数的函数，参数为tElement和tAttrs，并返回一个代表模板的字符串。
 
 AngularJS会同处理HTML一样处理模板字符串。模板中可以通过大括号标记来访问作用域，例如`{{ expression }}`。

 如果模板字符串中含有多个DOM元素，或者只由一个单独的文本节点构成，那它必须被包含在一个父元素内。换句话说，必须存在一个根DOM元素：

 ```
template: '\
    <div> <-- single root element -->\
        <a href="http://google.com">Click me</a>\
        <h1>When using two elements, wrap them in a parent element</h1>\
    </div>\
 ```

5. **templateUrl** （字符串或函数）
 
 templateUrl是可选的参数，可以是以下类型：
 - 一个代表外部HTML文件路径的字符串；
 - 一个可以接受两个参数的函数，参数为tElement和tAttrs，并返回一个外部HTML文件路径的字符串。
 
 通过Ajax异步加载大量的模板将严重拖慢一个客户端应用的速度。为了避免延迟，可以在部署应用之前对HTML模板进行缓存。在大多数场景下缓存都是一个非常好的选择，因为AngularJS通过减少请求数量提升了性能。

6. **replace()**布尔型
 
 replace是一个可选参数，如果设置了这个参数，值必须为true，因为默认值为false。
 默认值意味着模板会被当作子元素插入到调用此指令的元素内部，如果为true，模板将替换调用指令的元素。

7. **scope**指令作用域（布尔型或对象）
 
 scope参数是可选的，可以被设置为true或一个对象。默认值是false。

 内置指令ng-controller的作用，就是从父级作用域继承并创建一个新的子作用域。它会创建一个新的从父作用域继承而来的子作用域。
 ```
    <div ng-init="someProperty = 'some data'">
        <div ng-init="siblingProperty='moredata'">
            第二个div: {{ aThirdProperty }}
            <div ng-init="aThirdProperty = 'data for 3rd property'"
                ng-controller="appController">
                第三个div: {{ aThirdProperty }}
                <div ng-init="aFourthProperty">
                    第四个div: {{ aThirdProperty }}
                </div>
            </div>
        </div>
    </div>
    <script>
        var app =angular.module('app', []);

        app.controller('appController', ['$scope', function($scope){
            
        }])
    </
 ```

 <iframe frameborder="0" width="100%" src="partial/notes/angular/iframe/1.1.9.1.html">
    </iframe>

 如果要创建一个能够从外部原型继承作用域的指令，将scope属性设置为true：

 ```
    <div ng-app="app"
        ng-init="someProperty = 'some data'">
        <div ng-init="siblingProperty='moredata'">
            第二个div：{{ aThirdProperty }}

            <div ng-init="aThirdProperty = 'data for 3rd property'"
                ng-controller="SomeController">
                第三个div：{{ aThirdProperty }}
                <div ng-controller="SecondController">
                    第四个div：{{ aThirdProperty }}
                    <br>
                    Outside myDirective: {{ myProperty }}
                    <div my-directive ng-init="myProperty = 'wow, this is cool'">
                        Inside myDirective: {{ myProperty }}
                    </div>
                </div>
            </div>

        </div>
        
    </div>
    <script>
        var app = angular.module('app', []);

        app.directive('myDirective',function () {
            return {
                restrict:'A',
                scope:true
            }
        });

        app.controller('SomeController',['$scope',function ($scope) {
            /* body... */
        }])

        app.controller('SecondController',['$scope',function ($scope) {
            /* body... */
        }])
    </script>
 ```
 scope为true时，修改父域的值会影响到子域，修改子域不影响父域，因为子域是独立的；

 scope为 false时，修改父域的值会影响子域，修改子域也会影响父域，是双向绑定，scope配置默认值是false；

 scope为{}时，修改父域的值不影响子域，修改子域也不会影响父域，子域是完全隔离的作用域；

 **绑定策略**

 为了让新的指令作用域可以访问当前本地作用域中的变量，需要使用下面三种别名中的一种。

 1. `@ (or @attr)` 指令内部作用域可以使用外部作用域的变量
    
 2. `= (or =attr)` 可以将本地作用域上的属性同父级作用域上的属性进行双向的数据绑定。
 
 3. `& (or &attr)`  对父级作用域进行绑定，并将其中的属性包装成一个函数。要使调用带有一个参数的父方法，我们需要传递一个对象，这个对象的键是参数的名称，值是要传递给参数的内容。
 
8. **transclude**
 
 当transclude值为true时，指令获取指令元素的元素内容，并插入到指令模板中带·ng-transclude属性的标签中去

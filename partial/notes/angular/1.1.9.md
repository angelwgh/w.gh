## 指令定义

```
angular.module('myApp', [])
    .directive('myDirective', function ($timeout, UserDefinedService) {
    // 指令定义放在这里
        return {
        // 通过设置项来定义指令，在这里进行覆写
        };
    });
```

`directive()` 方法可以接受两个参数：
1. name（字符串）
 指令的名字，用来在视图中引用特定的指令。
2. factory_function （函数）
 这个函数返回一个对象，其中定义了指令的全部行为。 `$compile`服务利用这个方法返回的对象，在DOM调用指令时来构造指令的行为

```
angular.module('myApp', [])
    .directive('myDirective', function ($timeout, UserDefinedService) {
    // 指令定义放在这里
        return {
            restrict: String, //指令声明形式
            priority: Number, //指令优先级
            terminal: Boolean, //停止运行当前元素上比本指令优先级低的指令。
            template: String or Template Function:  //html模板
            function(tElement, tAttrs) {...},
            templateUrl: String,                     //html模板地址
            replace: Boolean or String,            //模板是否替换调用指令的元素
            scope: Boolean or Object,              //作用域
            transclude: Boolean,                   //
            controller: String or
                function(scope, element, attrs, transclude, otherInjectables) { ... },
            controllerAs: String,
            require: String,
            link: function(scope, iElement, iAttrs) { ... },
            compile: // 返回一个对象或连接函数，如下所示：
                function(tElement, tAttrs, transclude) {
                    return {
                        pre: function(scope, iElement, iAttrs, controller) { ... },
                        post: function(scope, iElement, iAttrs, controller) { ... }
                    }
                    // 或者
                    return function postLink(...) { ... }
                }
        };
    });
```

1. **restrict**（字符串）
 
 restrict是一个可选的参数。它告诉AngularJS这个指令在DOM中可以何种形式被声明。默
认AngularJS认为restrict的值是A，即以属性的形式来进行声明。

    *E（元素）*
    ```
    <my-directive></my-directive>
    ```
    *A（属性，默认值）*
    ```
    <div my-directive="expression"></div>
    ```
   *C（类名）*
    ```
    <div class="my-directive:expression;"></div>
    ```
   *M（注释）*
    ```
    <--directive:my-directive expression-->
    ```

    这些选项可以单独使用，也可以混合在一起使用：
    ```
    angular.module('myDirective', function(){
        return {
            restrict: 'EA' // 输入元素或属性
        };
    });
    ```

2. **priority** (数值)
 
 优先级，可以被设置为一个数值。大多数指令会忽略这个参数，使用默认值0。如果一个元素上具有两个优先级相同的指令，声明在前面的那个会被优先调用。如果其中一个的优先级更高，则不管声明的顺序如何都会被优先调用：具有更高优先级的指令总是优先运行。

 *ngRepeat是所有内置指令中优先级最高的，它总是在其他指令之前运行。*

3. **terminal** (布尔型)

 个参数用来告诉AngularJS停止运行当前元素上比本指令优先级低的指令。但同当前指令优先级相同的指令还是会被执行。

4. **template**（字符串或函数）
 
 模板字符串，参数是可选的，必须被设置为以下两种形式之一：
 - 一段HTML文本；
 -  一个可以接受两个参数的函数，参数为tElement和tAttrs，并返回一个代表模板的字符串。
 
 AngularJS会同处理HTML一样处理模板字符串。模板中可以通过大括号标记来访问作用域，例如`{{ expression }}`。

 如果模板字符串中含有多个DOM元素，或者只由一个单独的文本节点构成，那它必须被包含在一个父元素内。换句话说，必须存在一个根DOM元素：

 ```
template: '\
    <div> <-- single root element -->\
        <a href="http://google.com">Click me</a>\
        <h1>When using two elements, wrap them in a parent element</h1>\
    </div>\
 ```

5. **templateUrl** （字符串或函数）
 
 templateUrl是可选的参数，可以是以下类型：
 - 一个代表外部HTML文件路径的字符串；
 - 一个可以接受两个参数的函数，参数为tElement和tAttrs，并返回一个外部HTML文件路径的字符串。
 
 通过Ajax异步加载大量的模板将严重拖慢一个客户端应用的速度。为了避免延迟，可以在部署应用之前对HTML模板进行缓存。在大多数场景下缓存都是一个非常好的选择，因为AngularJS通过减少请求数量提升了性能。

6. **replace()**布尔型
 
 replace是一个可选参数，如果设置了这个参数，值必须为true，因为默认值为false。
 默认值意味着模板会被当作子元素插入到调用此指令的元素内部，如果为true，模板将替换调用指令的元素。

7. **scope**指令作用域（布尔型或对象）
 
 scope参数是可选的，可以被设置为true或一个对象。默认值是false。

 内置指令ng-controller的作用，就是从父级作用域继承并创建一个新的子作用域。它会创建一个新的从父作用域继承而来的子作用域。
 ```
    <div ng-init="someProperty = 'some data'">
        <div ng-init="siblingProperty='moredata'">
            第二个div: {{ aThirdProperty }}
            <div ng-init="aThirdProperty = 'data for 3rd property'"
                ng-controller="appController">
                第三个div: {{ aThirdProperty }}
                <div ng-init="aFourthProperty">
                    第四个div: {{ aThirdProperty }}
                </div>
            </div>
        </div>
    </div>
    <script>
        var app =angular.module('app', []);

        app.controller('appController', ['$scope', function($scope){
            
        }])
    </
 ```

 <iframe frameborder="0" width="100%" src="partial/notes/angular/iframe/1.1.9.1.html">
    </iframe>

 如果要创建一个能够从外部原型继承作用域的指令，将scope属性设置为true：

 ```
    <div ng-app="app"
        ng-init="someProperty = 'some data'">
        <div ng-init="siblingProperty='moredata'">
            第二个div：{{ aThirdProperty }}

            <div ng-init="aThirdProperty = 'data for 3rd property'"
                ng-controller="SomeController">
                第三个div：{{ aThirdProperty }}
                <div ng-controller="SecondController">
                    第四个div：{{ aThirdProperty }}
                    <br>
                    Outside myDirective: {{ myProperty }}
                    <div my-directive ng-init="myProperty = 'wow, this is cool'">
                        Inside myDirective: {{ myProperty }}
                    </div>
                </div>
            </div>

        </div>
        
    </div>
    <script>
        var app = angular.module('app', []);

        app.directive('myDirective',function () {
            return {
                restrict:'A',
                scope:true
            }
        });

        app.controller('SomeController',['$scope',function ($scope) {
            /* body... */
        }])

        app.controller('SecondController',['$scope',function ($scope) {
            /* body... */
        }])
    </script>
 ```
 scope为true时，修改父域的值会影响到子域，修改子域不影响父域，因为子域是独立的；

 scope为 false时，修改父域的值会影响子域，修改子域也会影响父域，是双向绑定，scope配置默认值是false；

 scope为{}时，修改父域的值不影响子域，修改子域也不会影响父域，子域是完全隔离的作用域；

 **绑定策略**

 为了让新的指令作用域可以访问当前本地作用域中的变量，需要使用下面三种别名中的一种。

 1. `@ (or @attr)` 指令内部作用域可以使用外部作用域的变量
    
 2. `= (or =attr)` 可以将本地作用域上的属性同父级作用域上的属性进行双向的数据绑定。
 
 3. `& (or &attr)`  对父级作用域进行绑定，并将其中的属性包装成一个函数。要使调用带有一个参数的父方法，我们需要传递一个对象，这个对象的键是参数的名称，值是要传递给参数的内容。
 
8. **transclude**
 
 当transclude值为true时，指令获取指令元素的元素内容，并插入到指令模板中带·ng-transclude属性的标签中去

 ```
    <div ng-controller="Ctrl">
          <input ng-model="title"><br>
          <textarea ng-model="text"></textarea> <br/>
          <pane title="{{title}}">{{text}}</pane>
    </div>
 ```

 pane是一个自定义derective，标签里还有一个表达式，这个指令的目的是显示 input中输入的title，和textarea中输入的text，当然是按照一定的dom结构显示。看下pane是如何实现：

 ```
 app.directive('pane', function(){
    return {
      restrict: 'E',
      transclude: true,
      scope: { title:'@' },
      template: '<div style="border: 1px solid black;">' +
                  '<div style="background-color: gray">                        {{title}}</div>' +
                  '<div ng-transclude></div>' +
                '</div>'
    };
 });
 ```

 首先是我们想把 `<pane title="{{title}}">{{text}}</pane>` 中{{title}}和{{text}}变量的内容封装到我们的dom结构中，{{title}} 可以通过结构`scope: { title:'@' }`取得，但是我们想要保留 `<pane></pane>`标签里的东西（有可能会是很多的表达式和dom结构），那就需要今天的主角 transclude了。

 这个例子的结果生成的dom结构是这样的：

 ```
 <div style="border: 1px solid black;">
    <div style="background-color: gray">我是标题</div>
    我是内容
  </div>
 ```

9.  **controller** （字符串或函数）
 
 controller参数可以是一个字符串或一个函数。当设置为字符串时，会以字符串的值为名字，来查找注册在应用中的控制器的构造函数

 ```
 angular.module('myApp', [])
    .directive('myDirective', function() {
        restrict: 'A', // 始终需要
        controller: 'SomeController'
    })
    // 应用中其他的地方，可以是同一个文件或被index.html包含的另一个文件
    angular.module('myApp')
        .controller('SomeController', function($scope, $element, $attrs, $transclude) {
            // 控制器逻辑放在这里
        });
 ```

 可以在指令内部通过匿名构造函数的方式来定义一个内联的控制器：

 ```
 angular.module('myApp',[])
    .directive('myDirective', function() {
        restrict: 'A',
        controller:
        function($scope, $element, $attrs, $transclude) {
            // 控制器逻辑放在这里
        }
    });
 ```

 控制器中有一些特殊的服务可以被注入到指令当中。这些服务有：

 -  **$scope**
     +  与指令元素相关联的当前作用域。
 - **$element**
     + 当前指令对应的元素。
 - **$attrs**
     + 由当前元素的属性组成的对象。例如，下面的元素：
       `<div id="aDiv"class="box"></div>`
       具有如下的属性对象：
       ```
        {
            id: "aDiv",
            class: "box"
        }
       ```
 
 - **$transclude**
     + 嵌入链接函数会与对应的嵌入作用域进行预绑定。
      ```
        var app = angular.module('app',[]);

        app.directive('alink', function(){
            // Runs during compile
            return {
                restrict:'EA',
                transclude:true,
                controller:
                    function ($scope,$element,$transclude,$log) {
                        $transclude(function (clone) {
                            //clone 指令内部的元素，被transclude的内容
                            //$element编译后的元素
                            var a = angular.element('<a>');//创建一个a元素
                            a.attr('href',clone.text());  //设置a元素的href属性
                            a.text(clone.text())          //设置a元素的文本内容
                            console.log(a)
                            $element.append(a)           //把a元素添加到指令标签内
                        })
                    }
            };
        });
      ```
 
10. **controllerAs**（字符串）
 
 controllerAs参数用来设置控制器的别名，可以以此为名来发布控制器，并且作用域可以访问controllerAs。这样就可以在视图中引用控制器，甚至无需注入$scope。
 
11. **require**（字符串或数组）
 
 require参数可以被设置为字符串或数组，字符串代表另外一个指令的名字。 require会将控制器注入到其值所指定的指令中，并作为当前指令的链接函数的第四个参数。

 require参数的值可以用下面的前缀进行修饰，这会改变查找控制器时的行为：
 - **?**
     + 如果在当前指令中没有找到所需要的控制器，会将null作为传给link函数的第四个参数。
 - **^**
     + 如果添加了^前缀，指令会在上游的指令链中查找require参数所指定的控制器。
 - **?^**
     + 将前面两个选项的行为组合起来，我们可选择地加载需要的指令并在父指令链中进行查找。
 - **没有前缀**
     + 如果没有前缀，指令将会在自身所提供的控制器中进行查找，如果没有找到任何控制器（或具有指定名字的指令）就抛出一个错误。

12. **compile** (对象或函数)
 
 指令编译，compile选项可以返回一个对象或函数。

 在编译阶段， AngularJS会遍历整个HTML文档并根据JavaScript中的指令定义来处理页面上声明的指令。一旦对指令和其中的子模板进行遍历或编译，编译后的模板会返回一个叫做模板函数的函数。我们有机会在指令的模板函数被返回前，对编译后的DOM树进行修改。

 在这个时间点DOM树还没有进行数据绑定，意味着如果此时对DOM树进行操作只会有很少的性能开销。如果设置了compile函数，说明我们希望在指令和实时数据被放到DOM中之前进行DOM操作。在这个函数中进行诸如添加和删除节点等DOM操作是安全的。

 编译函数(compile)负责对模板DOM进行转换。
 链接函数(link)负责将作用域和DOM进行链接。

 ```html
    <body ng-app="app">
    <div test='1'>
     <p>自定义指令</p>
     </div>
    <script>
        var app = angular.module('app', []);

        app.directive('test',function () {
            return{
                template:'<div>指令模板</div>',
                transclude:true,
                compile: function (tEle,tAttrs,transcludeFn) {
                    //tEle 变异后的指令元素
                    //指令元素上的属性
                    console.log(tEle.children().html())
                    console.log(tAttrs)
                    //console.log(transcludeFn);
                    return function (scope) {
                        transcludeFn(scope,function (clone) {
                            console.log(clone)
                            //clone 绑定指令的元素编译前包含的内容
                        })
                    }
                },
                
            }
        })
    </script>
</body>
 ```

 *compile和link选项是互斥的。如果同时设置了这两个选项，那么会把compile所返回的函数当作链接函数，而link选项本身则会被忽略。*

13. **link** 链接函数
 
 链接函数是可选的。如果定义了编译函数，它会返回链接函数，因此当两个函数都定义了时，编译函数会重载链接函数。如果我们的指令很简单，并且不需要额外的设置，可以从工厂函数 （回调函数）返回一个函数来代替对象。如果这样做了，这个函数就是链接函数。

 下面两种定义指令的方式在功能上是完全一样的：
 ```
    angular.module('myApp', [])
        .directive('myDirective', function() {
            return {
                pre: function(tElement, tAttrs, transclude) {
                    // 在子元素被链接之前执行
                    // 在这里进行Don转换不安全
                    // 之后调用'lihk'h函数将无法定位要链接的元素
                },
                post: function(scope, iElement, iAttrs, controller) {
                    // 在子元素被链接之后执行
                    // 如果在这里省略掉编译选项
                    //在这里执行DOM转换和链接函数一样安全吗
                }
            };
        });

    angular.module('myApp', [])
        .directive('myDirective', function() {
            return {
                link: function(scope, ele, attrs) {
                    return {
                        pre: function(tElement, tAttrs, transclude) {
                            // 在子元素被链接之前执行
                            // 在这里进行Don转换不安全
                            // 之后调用'lihk'h函数将无法定位要链接的元素
                        },
                        post: function(scope, iElement, iAttrs, controller) {
                            // 在子元素被链接之后执行
                            // 如果在这里省略掉编译选项
                            //在这里执行DOM转换和链接函数一样安全吗
                        }
                    }
                }
            }
        });
 ```

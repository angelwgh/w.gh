## 服务

到目前为止，我们只关心视图是如何同$scope绑定在一起，以及控制器是如何管理数据的。出于内存占用和性能的考虑，控制器只会在需要时被实例化，并且不再需要就会被销毁。这意味着每次切换路由或重新加载视图时，当前的控制器会被AngularJS清除掉。

服务提供了一种能在应用的整个生命周期内保持数据的方法，它能够在控制器之间进行通信，并且能保证数据的一致性。

服务是一个单例对象，在每个应用中只会被实例化一次（被`$injector`实例化），并且是延迟加载的（需要时才会被创建）。服务提供了把与特定功能相关联的方法集中在一起的接口。

```js
// 示例服务，在应用的整个生命周期内保存current_user
angular.module('myApp', [])
    .factory('UserService', function($http) {
        var current_user;
        return {
            getCurrentUser: function() {
                return current_user;
            },
            setCurrentUser: function(user) {
                current_user = user;
            }
        };
    });

```

AngularJS提供了一些内置服务，在任何地方使用它们的方式都是统一的。同时，为复杂应用创建我们自己的服务也是非常有用的。

### 注册服务

使用angular.module的factory API创建服务，是最常见也是最灵活的方式：

```
angular.module('myApp.services', [])
.factory('githubService', function() {
        var serviceInstance = {};
        // 我们的第一个服务
        return serviceInstance;
    });
```

尽管githubService没做什么有趣的事情，但现在它已经用githubService作为名字注册成为这个AngularJS应用的一个服务了。

服务的工厂函数用来生成一个单例的对象或函数，这个对象或函数就是服务，它会存在于应用的整个生命周期内。当我们的AngularJS应用加载服务时，这个函数会被执行并返回一个单例的服务对象。

同创建控制器的方法一样，服务的工厂函数既可以是一个函数也可以是一个数组：

```
angular.module('myApp.services', [])
    .factory('githubService', [function($http) { }]);
```


例如， githubService需要访问$http服务，所以我们将$http服务当作AngularJS应用的一个依赖，并将它注入到工厂函数中。

```
angular.module('myApp.services', [])
    .factory('githubService', function($http) {
        // 我们的serviceInstance现在可以在函数定义中访问$http服务
        var serviceInstance = {};
        return serviceInstance;
    });
```


GitHub API提供了一个读取用户活动流的方法（活动流就是用户记录在GitHub中的最近的事件列表）。在我们的服务中，可以创建一个访问这个API的方法，并将API的请求结果返回。

```js
angular.module('myApp.services', [])
    .factory('githubService', function($http) {
        var githubUrl = 'https://api.github.com';
        var runUserRequest = function(username, path) {
        // 从使用JSONP调用Github API的$http服务中返回promise
            return $http({
                method: 'JSONP',
                url: githubUrl + '/users/' +
                username + '/' +
                path + '?callback=JSON_CALLBACK'
            });
        };
    // 返回带有一个events函数的服务对象
        return {
            events: function(username) {
                return runUserRequest(username, 'events');
            }
        }
    })
```

githubService中只包含了一个方法，可以在应用的模块中调用。

### 使用服务

可以在控制器、指令、过滤器或另外一个服务中通过依赖声明的方式来使用服务。 AngularJS会像平时一样在运行期自动处理实例化和依赖加载的相关事宜。

将服务的名字当作参数传递给控制器函数，可以将服务注入到控制器中。当服务成为了某个控制器的依赖，就可以在控制器中调用任何定义在这个服务对象上的方法。

```js
angular.module('myApp', ['myApp.services'])
    .controller('ServiceController', function($scope, githubService) {
    // 我们可以调用对象的事件函数
    $scope.events = githubService.events('auser');
});
```

githubService服务已经被注入到ServiceController中，可以像使用任何其他服务一样使用它。

修改一下例子，用视图中输入的GitHub用户名为参数来访问GitHub API,将username属性和视图进行绑定。

```html
<div ng-controller="ServiceController">
    <label for="username">
        Type in a GitHub username
    </label>
    <input type="text"
        ng-model="username"
        placeholder="Enter a GitHub username" />
    <ul>
        <li ng-repeat="event in events">
        <!--
        event.actor and event.repo are returned
        by the github API. To view the raw
        API, uncomment the next line:
        -->
        <!-- {{ event | json }} -->
        {{ event.actor.login }} {{ event.repo.name }}
        </li>
    </ul>
</div>
```

基于双向数据绑定，我们现在可以通过监视`$scope.username`来响应视图中的数据变化。

```js
.controller('ServiceController',
    function($scope, githubService) {
        // 注意username属性的变化
        // 如果有变化就运行该函数
        $scope.$watch('username', function(newUsername) {
            // 从使用JSONP调用Github API的$http服务中返回promise
            githubService.events(newUsername)
                .success(function(data, status, headers){
                    // success函数在数据中封装响应
                    //因此我们需要调用data.data来获取原始数据
                    $scope.events = data.data;
                    })
            })
        })
```

由于$http返回的是promise对象，可以通过.success()方法像直接调用$http一样
调用返回的对象。

在这个例子中，需要有一个延时，如果不延时，将导致输入字段中的任何一个键盘输入都会让终端对GitHub API进行调用，这显然不是我们希望的。

通过内置服务`$timeout`来介绍一下这个延时。同注入githubService一样，需要将`$timeout`服务注入到控制器中：

```
app.controller('ServiceController', function($scope, $timeout, githubService) {
});
```

现在可以在控制器中使用$timeout服务了。在这个例子中`$timeout`服务会取消所有网络请求，并在输入字段的两次变化之间延时350ms。换句话说，如果用户两次输入之间有350 ms的间隔，就推断用户已经完成了输入，然后开始向GitHub发送请求：

```js
app.controller('ServiceController', function($scope, $timeout, githubService) {
// 和上面的示例一样, 添加了$timeout服务
    var timeout;
    $scope.$watch('username', function(newUserName) {
        if (newUserName) {
        // 如果在进度中有一个超时(timeout)
            if (timeout) $timeout.cancel(timeout);
            timeout = $timeout(function() {
                githubService.events(newUserName)
                .success(function(data, status) {
                    $scope.events = data.data;
                });
            }, 350);
        }
    });
});
```

到现在为止，我们只介绍了服务如何将类似的功能打包在一起，而使用服务也是在控制器之间共享数据的典型方法。

为了在控制器之间共享数据，需要在服务中添加一个用来储存用户名的方法。记住，服务在应用的生命周期内是单例模式的，因此可以将用户名安全地储存在其中。

```js
angular.module('myApp.services', [])
.factory('githubService', function($http) {
    var githubUrl = 'https://api.github.com',
    githubUsername;
    var runUserRequest = function(path) {
    // 从使用JSONP的Github API的$http服务中返回promise
        return $http({
            method: 'JSONP',
            url: githubUrl + '/users/' +
            githubUsername + '/' +
            path + '?callback=JSON_CALLBACK'
        });
    };
    // 返回带有两个方法的服务对象
    // 事件
    // 和setUsername
    return {
        events: function() {
        return runUserRequest('events');
    },
    setUsername: function(username) {
        githubUsername = username;
    }
    };
});
```


现在，服务中有一个setUsername方法，用来保存当前的GitHub用户名了。

githubService可以注入到应用的任何一个控制器中，并可以在控制器中调用events()方法，且无须担心当前作用域对象上的用户名是否是正确的。

```
angular.module('myApp', ['myApp.services'])
    .controller('ServiceController',
    function($scope, githubService) {
        $scope.setUsername =
        githubService.setUsername;
    });
```


### 创建服务时的设置项

在AngularJS应用中， factory()方法是用来注册服务的最常规方式，同时还有其他一些API可以在特定情况下帮助我们减少代码量。共有5种方法用来创建服务：

- factory()
- service()
- constant()
- value()
- provider()

1. **factory()**
 
  factory()方法是创建和配置服务的最快捷方式。 factory()函数可以接受两个参数。
 - name（字符串）
     + 需要注册的服务名
 - getFn（函数）
     + 这个函数会在AngularJS创建服务实例时被调用。

 ```js
 var myModule = angular.module('myModule', []);
    myModule.factory('serviceId', function() {
      var shinyNewServiceInstance;
      // factory function body that constructs shinyNewServiceInstance
      return shinyNewServiceInstance;
    });
 ```
 
 注意这并没有注册一个服务实例，而是一个工厂函数，它将在被调用时创建这个实例。

 服务可以有自己的依赖，就跟在控制器中声明依赖关系一样，可以通过指定的工厂函数签名声明服务依赖

 ```js
 var batchModule = angular.module('batchModule', []);

 batchModule.factory('batchLog', ['$interval', '$log', function($interval, $log) {
    var messageQueue = [];
    function log() {
        if (messageQueue.length) {
          $log.log('batchLog messages: ', messageQueue);
          messageQueue = [];
        }
      };
      $interval(log, 50000);//$interval服务类似于setInterval
      return function(message) {
        messageQueue.push(message);
      }
    }])
 ```
 
 getFn函数可以返回简单类型、函数乃至对象等任意类型的数据（同value()函数类似）。

2. **service()**
 
 使用service()可以注册一个支持构造函数的服务，它允许我们为服务对象注册一个构造函数。

 service()方法接受两个参数。
 - name（字符串）
     + 要注册的服务的名字
 - constructor（函数）
     + 构造函数，我们调用它来实例化服务对象。
 
 service()函数会在创建实例时通过new关键字来实例化服务对象。
 
 ```js
    var Person = function($http) {
        this.getName = function() {
            return $http({ method: 'GET', url: '/api/user'});
        };
    };
    angular.service('personService', Person);
 ```

 通过service方式创建自定义服务，相当于new的一个对象：`var s = new myService();`，只要把属性和方法添加到this上才可以在controller里调用。

3. **provider()**
 
 所有服务工厂都是由`$provide`服务创建的， `$provide`服务负责在运行时初始化这些提供者。提供者是一个具有`$get()`方法的对象， `$injector`通过调用$get方法创建服务实例。

 ```js
    function factory(name, factoryFn, enforce) {
        return provider(name, {
          $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
        });
      }
 ```

 我们可以用AngularJS的.config()函数来对.provider()方法返回的服务进行额外的扩展配置。同其他创建服务的方法不同， config()方法可以被注入特殊的参数。

 比如我们希望在应用启动前配置githubService的URL：
 ```js
 // 使用`.provider`注册该服务
 angular.module('myApp',[])
    .provider('githubService', function($http) {
        // 默认的，私有状态
        var githubUrl = 'https://github.com';
        return{
            setGithubUrl : function(url){
                // 通过.config改变默认属性
                if (url) { githubUrl = url }
            },
            method: JSONP,
            $get:function($http){
                self = this;
                return $http({ method: self.method, url: githubUrl + '/events'});
            } 
        }
        
        })

 ```

 在上面的例子中，provider()方法在文本githubService后添加Provider生成了一个新的提供者， githubServiceProvider可以被注入到config()函数中。

 ```js
 angular.module('myApp', [])
    .config(function(githubServiceProvider) {
        //在注入provider时，名字应该是：providerName+Provider 
        githubServiceProvider.setGithubUrl("git@github.com");
    });
 ```
